<!-- templates/index.html -->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Real-Time Transcription</title>
    <style>
        body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; background-color: #f0f0f0; margin: 0; }
        #recordButton { padding: 20px; font-size: 1.2em; cursor: pointer; border: none; border-radius: 50%; width: 100px; height: 100px; background-color: #87CEEB; color: white; transition: background-color 0.3s; margin-bottom: 20px; }
        #recordButton.recording { background-color: #FF6347; }
        #status { font-size: 1.1em; color: #333; height: 30px; }
        #transcription { margin-top: 20px; width: 80%; max-width: 800px; height: 300px; border: 1px solid #ccc; background-color: white; padding: 10px; overflow-y: scroll; font-size: 1.2em; line-height: 1.5; }
    </style>
</head>
<body>

    <button id="recordButton">Record</button>
    <div id="status">Status: Not Connected</div>
    <div id="transcription"></div>

    <script>
        const recordButton = document.getElementById('recordButton');
        const statusDiv = document.getElementById('status');
        const transcriptionDiv = document.getElementById('transcription');

        let mediaRecorder;
        let webSocket;
        let isRecording = false;

        recordButton.addEventListener('click', async () => {
            if (!isRecording) {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                    webSocket = new WebSocket(`${protocol}//${window.location.host}/ws`);

                    webSocket.onopen = () => {
                        statusDiv.textContent = 'Status: Connected. Recording...';
                        recordButton.textContent = 'Stop';
                        recordButton.classList.add('recording');
                        isRecording = true;
                        transcriptionDiv.innerHTML = '';

                        mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm; codecs=opus' });
                        mediaRecorder.ondataavailable = (event) => {
                            if (event.data.size > 0 && webSocket.readyState === WebSocket.OPEN) {
                                webSocket.send(event.data);
                            }
                        };
                        mediaRecorder.start(250);
                    };

                    // *** NEW: Handle incoming text from the server ***
                    webSocket.onmessage = (event) => {
                        const message = event.data;
                        transcriptionDiv.innerHTML += message + ' ';
                        transcriptionDiv.scrollTop = transcriptionDiv.scrollHeight; // Auto-scroll
                    };

                    webSocket.onclose = () => { stopRecording(); };
                    webSocket.onerror = (error) => {
                        console.error('WebSocket Error:', error);
                        stopRecording();
                    };

                } catch (error) {
                    console.error('Error accessing microphone:', error);
                }
            } else {
                stopRecording();
            }
        });

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state === 'recording') mediaRecorder.stop();
            if (webSocket && webSocket.readyState === WebSocket.OPEN) webSocket.close();

            recordButton.textContent = 'Record';
            recordButton.classList.remove('recording');
            statusDiv.textContent = 'Status: Not Connected';
            isRecording = false;
        }
    </script>
</body>
</html>